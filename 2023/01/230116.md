# Spring
## SOLID
* #### 객체지향 프로그래밍 및 설계를 위한 다섯 가지 기본 원칙

### SRP(Single Responsibility Principle) 단일 책임 원칙
* #### 한 클래스는 하나의 책임만 가져야 한다.
* #### 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 함을 의미한다.
* #### 각 클래스는 하나의 개념을 나타내어야 하며, 클래스는 자신의 이름이 나타내는 일을 해야 한다. (올바른 클래스 이름이 해당 클래스의 책임을 나타낼 수 있는 방법)
* #### 책임의 영역이 확실해지기 때문에 다른 책임의 변경으로의 연쇄작용에서 자유로울 수 있다.
* #### 또한 책임을 적절히 분배함으로써 코드의 가독성이 향상되고, 유지보수가 용이해진다.
* #### 리팩토링을 이용하여 SRP를 지킬 수 있다.


### OCP(Open/Closed Principle) 개방-폐쇄 원칙
* #### 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
* #### 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화해야 한다는 의미이다.
* #### 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다.
* #### OCP는 관리가능하고 재사용 가능한 코드를 만드는 기반이다.
* #### 추상화와 다형성이 OCP를 가능하게 하는 중요 메커니즘이다.
* #### 추상화는 다른 모든 종류의 객체로부터 식별될 수 있는 객체의 본질적인 특성이다.

### LSP(Liskov Substitution Principle) 리스코프 치환 원칙
* #### 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
* #### 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
* #### LSP 위반의 예시는 직사각형과 정사각형이 있다.

### ISP(Interface Segregation Principle) 인터페이스 분리 원칙
* #### 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
* #### (하나의 일반적인 인터페이스보다는 여러 개의 구체적인 인터페이스가 낫다.)
* #### 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
* #### SRP가 클래스의 단일책임을 강조한다면, ISP는 인터페이스의 단일책임을 강조한다.

### DIP(Dependency Inversion Principle) 의존관계 역전 원칙
* #### 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다. (DI는 이 원칙을 따르는 방법 중 하나이다.)
* #### IOC, 훅 메서드, 확장성이 조합되어 복잡한 컴포넌트들의 관계를 단순화하고 컴포넌트 간의 커뮤니케이션을 효율적이게 한다.

### AppConfig
* #### AppConfig는 애플리케이션의 전체 동작방식을 구성(config)하기 위해, 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스이다.
* #### 클래스 명은 AppConfig가 아니어도 된다.
* #### 구현 객체를 생성하고, 생성한 객체 인스턴스의 참조를 생성자를 통해서 주입해준다.
* #### AppConfig 같은 클래스를 사용하지 않는다면, 클라이언트 코드가 구체 클래스에 의존하기 때문에 DIP를 위반하게 된다.
* #### AppConfig를 사용하게 되면, 클라이언트 코드 대신 객체 인스턴스를 생성해서 클라이언트 코드에 의존관계를 주입해줌으로써, DIP 원칙을 따를 수 있게 되었다.
* #### 또한, AppConfig에서 의존관계를 변경하여 클라이언트에 주입하므로 클라이언트 코드는 변경하지 않아도 된다.
* #### 따라서 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있게 된다. (OCP)
* #### 그리고 애플리케이션이 사용 영역과, 객체를 생성하고 구성(Configuration)하는 영역으로 분리된다.

### 제어의 역전 IoC(Inversion of Control)
* #### 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고 실행했다. (구현 객체가 프로그램의 제어 흐름을 스스로 조종)
* #### AppConfig가 등장하면서, 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. (제어 흐름을 AppConfig가 가져감)
* #### 이렇게 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라 한다.

### DI(dependency Injection)
* #### 정적인 클래스 의존관계 : 클래스가 사용하는 import코드만 보고 의존관계를 쉽게 판단할 수 있다.
* #### 동적인 객체 인스턴스 의존관계 : 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.
* #### 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 의존관계 주입이라 한다.
* #### 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.
* #### 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
* #### 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

### IoC컨테이너, DI컨테이너
* #### AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC컨테이너 또는 **DI컨테이너**라 한다.
* #### 또는 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.

