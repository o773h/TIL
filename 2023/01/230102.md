# Java
### 추상클래스(abstract class)
* #### 클래스가 설계도라면, 추상클래스는 미완성 설계도에 비유할 수 있다.
* #### 즉, **미완성된 메서드(추상 메서드)를 포함하고 있는 클래스**이다.
* #### 자손은 추상클래스를 상속받아 구현해야 한다. (미 구현시 추상클래스로 남아있음)

### 추상메서드(abstract method)
* #### 메서드의 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것

```java
abstract class Player { // 추상클래스
    abstract void play(int pos); //추상메서드
    abstract void stop(); //추상메서드
}

class AudioPlayer extends Player {
    void play(int pos) {
        // 어쩌구 저쩌구 (내용 생략 - 구현했다고 가정)
    }
    void stop() {
        // 어쩌구 저쩌구 (내용 생략 - 구현했다고 가정)
    }
}

abstract class AbstractPlayer extends Player {
    void play(int pos) {
        // 어쩌구 저쩌구 (이건 구현했지만, stop메서드를 구현하지 않았기 때문에 추상클래스이다.)
    }
}
```

### 인터페이스(interface)
* #### 인터페이스는 일종의 추상클래스이다.
* #### 추상클래스와 달리 **오직 추상메서드와 상수만을 멤버로 가질 수 있다.**
```java
interface 인터페이스이름 {
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
}
```
* #### 모든 멤버변수는 **public static final** 이어야하며, 이를 **생략할 수 있다.**
* #### 모든 메서드는 **public abstract**이어야 하며, 이를 **생략할 수 있다.**
* #### (단, s**tatic메서드와 디폴드 메서드는 예외** (JDK1.8부터))

### 인터페이스의 상속
* #### 인터페이스는 인터페이스로부터만 상속받을 수 있다.
* #### 클래스와 달리 **다중상속 받는 것이 가능**하다.
* #### 클래스와 달리 Object클래스와 같은 최고 조상이 없다.
```java
interface Movable {
    void move(int x,int y);
}
interface Attackable {
    void attack(Unit u);
}
interface Fightable extends Movable,Attackable {}
```
### 인터페이스의 구현
* #### 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없다.
* #### 자신의 추상메서드를 구현한 클래스가 있어야 인스턴스를 생성할 수 있다.
```java
class 클래스이름 implements 인터페이스이름{
    // 인터페이스에 정의된 추상메서드를 구현해야 한다.
}
abstract class 클래스이름 implements 인터페이스이름{
    // 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야 한다.
}
```
### 인터페이스를 이용한 다형성
* #### **인터페이스의 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스의 타입으로의 형변환도 가능하다.**
* #### (인터페이스에 정의된 멤버들만 호출이 가능하다.)
```java
Fightable f = (Fightable)new Fighter();
//또는
Fightable f = new Fighter();
```

```java
Fightable method() {
    Figther f = enw Fighter();
    return f;

    // return new Fighter(); 과 같다
}
```
* #### **리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.**

### 인터페이스의 장점
* #### **개발시간을 단축시킬 수 있다.**
* #### **표준화가 가능하다.**
* #### (=*기본 틀을 인터페이스로 작성* 후, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 일관되고 정형화된 프로그램의 개발이 가능)
* #### **서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.**
* #### (=클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다.)
* #### **독립적인 프로그래밍이 가능하다.**
* #### (=인터페이스를 이용하면 클*래스의 선언과 구현을 분리*시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다.)

### 인터페이스의 이해
* #### 클래스를 사용하는 쪽(user)과 클래스를 제공하는 쪽(provider)이 있다.
* #### 메서드를 사용(호출)하는 쪽(user)에서는 사용하려는 메서드(provider)의 선언부만 알면 된다.(내용은 몰라도 된다.)

### 디폴트 메서드와 static메서드
* #### JDK1.8부터 디폴트 메서드와 static메서드도 인터페이스에 추가할 수 있게 되었다.
* #### **인터페이스에 메서드를 추가**한다는 것은, 추상메서드를 추가한다는 것이고, 인터페이스를 **구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현**해야 한다는 것이다.
* #### 이를 **해결하기 위해 나온 것이 디폴트 메서드**이다.
``` java
interface 인터페이스 {
    void method(); // 추상메서드
    default void newMethod() {} // 구현
}
```
#### 디폴트 메서드가 기존의 메서드와 이름이 중복되어 충돌하는 경우 해결하는 규칙은 다음과 같다.
* #### 여러 인터페이스의 디폴트 메서드 간의 충돌
* #### (인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.)
* #### 디폴트 메서드와 조상 클래스 메서드 간의 충돌
* #### (조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.)

### 내부 클래스(inner class)
* #### 클래스 내에 선언된 클래스이다.
* #### 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
* #### 코드의 복잡성을 줄일 수 있다. (캡슐화)
```java
class A { // 외부 클래스
    class B{ //내부 클래스
        //어쩌구 저쩌구
    }
}
```
### 내부 클래스의 종류와 특징
* #### 선언위치에 따라 다음과 같이 구분된다.
* #### 인스턴스 클래스 : 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. (주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용)
* #### 스태틱 클래스 : 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. (주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언)
* #### 지역 클래스 : 외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.
* #### 익명 클래스 : 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용이다.)
```java
class Outer{ //외부 클래스
    class InstanceInner{} //인스턴스 클래스
    static class StaticInner{} // 스태틱 클래스

    void method{
        class LocalInner{} // 지역 클래스
    }
}
```
### 익명 클래스
* #### 익명 클래스는 다른 내부 클래스들과는 달리 이름이 없다.
* #### 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용도리 수 있고, 오직 하나의 객체만을 사용할 수 있는 일회용 클래스이다.
```java
new 조상클래스이름() {
    // 멤버 선언
}
//또는
new 구현인터페이스이름() {
    //멤버 선언
}
```
```java
class InnerClass{
    Object iv = new Object() {void method() {}}; //익명 클래스
    static Object cv = new Object() {void method() {}}; //익명 클래스

    void newMethod() {
        Object lv = new Object() {void method() {}}; //익명 클래스
    }
}
```
