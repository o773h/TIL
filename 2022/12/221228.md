# 알고리즘
## BOJ 1931 회의실 배정
### 그리디 알고리즘을 이용하여 현재 상태의 최선의 선택을 이어나가 문제를 해결함
### 블로그 포스팅 :  <https://o773h.tistory.com/15>

---
# Java
## 객체지향 프로그래밍(OOP, Object-Oriented Programming)
### 객체지향 언어의 장점
* #### **코드의 재사용성이 높다.** (새로운 코드 작성시 기존의 코드 이용 가능)
* #### **코드의 관리가 용이하다.** (코드간의 관계를 이용하여 쉽게 코드 변경 가능)
* #### **신뢰성이 높은 프로그래밍을 가능하게 한다.** (제어자와 메서드를 이용하여 데이터를 보호하고 올바른 값을 유지, 코드의 중복을 제거하여 코드의 불일치로 인한 오작동 방지)

#### **클래스**란 객체를 정의해 놓은 것으로, 객체를 생성하는데 사용
#### 클래스로부터 객체를 만드는 과정을 클래스의 **인스턴스화**라고 하고, 클래스로부터 만들어진 객체를 그 클래스의 **인스턴스(instance)** 라고 한다.

```java
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
```

>#### *인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.*

### 객체 배열
#### 객체가 저장되는 것이 아니고, 객체의 주소가 저장된다.
```java
Tv[] tvArr = new Tv[3]; //참조변수 배열(객체 배열)을 생성
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
```
```java
Tv[] tvArr = {new Tv(), new Tv(), new Tv()}; //배열의 초기화 블럭을 사용가능
```
```java
Tv[] tvArr = new Tv[100];
for(int i=0;i<tvArr.length;i++){
    tvArr[i] = new Tv();
} // 다뤄야할 객체의 수가 많을 때는 for문을 이용
```
---
### 변수의 종류
#### 1. 인스턴스 변수(instance variable)
* #### 클래스 영역에 선언, 클래스의 인스턴스를 생성할 때 만들어진다.
* #### 인스턴스는 **독립적인 저장공간**을 가지므로 서로 다른 값을 가질 수 있다.
#### 2. 클래스변수(class variable)
* #### 인스턴스 변수 앞에 **static**을 붙여서 선언한다.
* #### 인스턴스마다 독립적인 저장공간을 갖는 인스턴스변수와 달리, 클래스변수는 **모든 인스턴스가 공통된 저장공간(변수)을 공유**하게 된다.
* #### **인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있다.** '클래스이름.클래스변수'와 같은 형식으로 사용
* #### **클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때 까지 유지**
* #### **public**을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근 할 수 있는 **전역변수**의 성격을 갖는다.
#### 3. 지역변수(local variable)
* #### 메서드 내에 선언되어 **메서드 내에서만 사용가능**하며, 메서드가 종료되면 소멸

```java
class Variables
{
    int iv; //인스턴스 변수
    static int cv; //클래스 변수

    void method()
    {
        int lv = 0; //지역 변수
    }
}
```
---
### JVM의 메모리 구조
* #### 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당 받음
* #### JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
#### 1.메서드 영역(method area)
* #### 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일을 읽고 분석하여 **클래스에 대한 정보**를 이곳에 저장한다.
* #### 이 때, 그 클래스의 클래스변수도 이 영역에 함께 생성된다.
#### 2.힙(heap)
* #### **인스턴스가 생성되는 공간**. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.
* #### 즉, 인스턴스 변수들이 생성되는 공간이다.
#### 3.호출스택(call stack 또는 execution stack)
* #### 호출스택은 **메서드의 작업에 필요한 메모리 공간**을 제공한다.
* #### 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당된다.
* #### 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다.
* #### 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.

#### 호출스택 과정
1. #### 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
2. #### 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거한다.
* #### 호출스택의 제일 위에 있는 메서드가 실행 중인 메서드이다.
* #### 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

>#### 반환타입이 '참조형' -> '객체의 주소'를 반환함을 의미한다.
---

### 클래스 메서드(static 메서드)와 인스턴스 메서드
* #### 클래스 메서드도 클래스변수처럼 **객체를 생성하지 않고도 호출이 가능하다.**
* #### 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는 메서드이다. (작업을 수행하는데 인스턴스 변수가 필요)
* #### 인스턴스와 관계없는 메서드를 클래스 메서드로 정의한다. (인스턴스 변수나 인스턴스 메서드를 사용X)
### 클래스 변수 및 클래스 메서드 정리
1. #### 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
   * #### 생성된 인스턴스는 서로 독립적이기 때문에 각 인스턴스 변수는 서로 다른 값을 가진다.
   * #### 모든 인스턴스에서 **같은 값이 유지되어야 하는 변수는 static을 붙여 클래스변수로 정의**해야 한다.
2. #### 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
   * #### static이 붙은 변수는 **클래스가 메모리에 올라갈 때 자동적으로 생성된다.**
3. #### **클래스메서드는 인스턴스 변수를 사용할 수 없다.**
   * #### 인스턴스변수는 인스턴스가 반드시 존재해야 사용가능하지만, 클래메서드는 인스턴스 생성 없이 호출가능하므로 클래스 메서드가 호출됐을 때 인스턴스가 존재하지 않을 수 있다. 따라서 사용을 금지한다.
   * #### 반면 인스턴스변수나 인스턴스메서드에서 static이 붙은 멤버를 사용하는 것은 언제나 가능하다.
4. #### 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
   * #### **메서드 호출시간이 짧아지므로 성능이 향상된다.**
   * #### 인스턴스메서드는 실행 시 호출되어야 할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.
